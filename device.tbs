include "global.tbh"

const DEV_STAMP = "DEVICE> "
const AGG_MAX_RETRY=4
'------------------------------------------------------------------------------
declare sub device_stg_mod_sg(byref stg_name as string, index as byte, byref stg_val as string, op as en_stg_rdwr)

'------------------------------------------------------------------------------
public dim led_pat_to_play,led_pat_to_play_prev as string(18)
public dim reboot_timer as byte
public dim agg_retry_counter as byte
public dim last_sntp_date as word
public dim param_st(NUM_OF_SLOTS) as en_slot_type
public dim param_io(NUM_OF_IO) as io_type
public dim param_sp(4) as byte
public dim param_se(4) as byte
public dim param_fc(4) as byte
public dim param_br(4) as byte
public dim param_pr(4) as byte
public dim param_bb(4) as byte
public dim param_bp(4) as boolean
public dim param_te as byte
public dim param_aggEvents as agg_events
public dim s_sock as byte
public dim lcd_error_mode as boolean

dim dhcp_failed(2) as no_yes

dim prev_login_mode as cmd_modes

#if WLN_AVAILABLE 
	public dim wln_dev_rescan_tmr as byte
	public dim wln_want_to_change_ap as no_yes
	public dim wln_rescanning as no_yes
	public dim rssi_update_timer as byte
	
	#if SUPPORTS_DISPLAY
		public dim wln_network_state as en_network_states
	#endif
#endif

#if SUPPORTS_DISPLAY
	public dim agg_cmd_received as no_yes
	public dim lan_network_state as en_network_states

	dim ib_chr_timer as byte
	dim input_box_mode as en_ib_mode
	dim ib_init as no_yes
	dim chr_init as no_yes	'flag used to decide if add a new character, or replace the current character.
	dim agg_cmd_progress as byte
	dim prev_icon as byte
	
#endif

declare agg_sock as byte
declare agg_sychronized as no_yes
declare sub agg_data_send(s as string)
declare sub gprs_start_over()
declare function agg_stg_msg(stg_result as en_stg_status_codes) as string
declare sub agg_invisible_separators(byref s as string)


'==============================================================================
sub callback_agg_pre_buffrq(x as byte)

end sub

'------------------------------------------------------------------------------
sub callback_agg_buff_released()
	if reboot_flag=YES then sys.reboot
end sub

'------------------------------------------------------------------------------
sub callback_agg_error(failure_code as en_agg_status_codes, byref error_item as string)
	
	#if SUPPORTS_GPRS
		if failure_code=EN_AGG_STATUS_CONNECTION_LOST then
			if agg_retry_counter>0 then 
				agg_retry_counter=agg_retry_counter-1
				if agg_retry_counter=0 then
					agg_stop()
					select case current_interface
	
					case PL_SOCK_INTERFACE_WLN:
						
					case PL_SOCK_INTERFACE_PPP:
						if current_interface=PL_SOCK_INTERFACE_PPP then
							#if DEV_DEBUG_PRINT
								dev_debugprint("Restart GPRS")
							#endif

							interface_ready(PL_SOCK_INTERFACE_PPP)=NO
							gprs_start_over()
						end if							
					case else
					
					end select

				end if
			else
				agg_retry_counter=AGG_MAX_RETRY
			end if
		end if
	#endif
	
end sub

'------------------------------------------------------------------------------
function callback_agg_external_data_source(byref source_type as string, byref parameter1 as string, byref parameter2 as string, byref parameter3 as string, rw as en_agg_rdwr)as ok_ng
	callback_agg_external_data_source=OK
	
end function

'------------------------------------------------------------------------------
function callback_agg_external_data_modtime_sg(byref source_type as string, byref item_name as string, byref date_time as string, op as en_agg_rdwr) as ok_ng
	callback_agg_external_data_modtime_sg=OK

end function
'------------------------------------------------------------------------------
function callback_agg_setting_saved(byref setting_name as string, index as byte, byref setting_val as string) as en_stg_status_codes

	select case setting_name
			' PWM Pulse Values
		case "EV":
			if index >= 0 or index < MAX_ANALOG_LINES then
				analog_pwm_pulse(index) = val(setting_val)
			end if
		
			' PWM Period Values
		case "FV":
			if index >= 0 or index < MAX_ANALOG_LINES then
				analog_pwm_period(index) = val(setting_val)
			end if
		
			' PWM Prescaler Values
		case "GV":
			if index >= 0 or index < MAX_ANALOG_LINES then
				analog_pwm_prescaler(index) = val(setting_val)
			end if
		
			' PWM Channel Enable
		case "HV":
			if index >= 0 or index < MAX_ANALOG_LINES then
				analog_pwm_enable(index) = val(setting_val)
			end if

		case "BO":
			if index = 0 then
				bp_setupPollingTime = val(setting_val)
			end if

		case "AA":
			if index = 0 then
				param_aggEvents.agg_eventAnalog = val(setting_val)
			end if

		case "AD":
			if index = 0 then
				param_aggEvents.agg_eventDigital = val(setting_val)
			end if

		case "AC":
			if index = 0 then
				param_aggEvents.agg_eventCounter = val(setting_val)
			end if

		case "AB":
			if index = 0 then
				param_aggEvents.agg_eventBP = val(setting_val)
			end if
	end select 

end function

'------------------------------------------------------------------------------
sub callback_agg_setting_error(byref setting_name as string, error_code as en_stg_status_codes)

end sub

'------------------------------------------------------------------------------
function utf8_translate(byref data as string) as string
	
	dim result as string
	dim i, j as byte
	dim sym as byte
	dim big_sym as dword
	
	result = ""
	j = 0
	for i = 1 to len(data)
		
		sym = asc(mid(data, i, 1))
		if j = 0 then
			if (sym and 128) = 0 then 
				' Pure ASCII
				result = result + chr(sym)
			else
				if (sym and 64) <> 0 then
					if (sym and 32) = 0 then
						' 110xxxxx 10xxxxxx
						j = 1
						big_sym = sym and 31
					else
						if (sym and 16) = 0 then
							' 1110xxxx 10xxxxxx 10xxxxxx
							j = 2
							big_sym = sym and 15
						else
							if (sym and 8) = 0 then
								' 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 
								j = 3
								big_sym = sym and 7
							else
								if (sym and 4) = 0 then
									' 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 
									j = 4
									big_sym = sym and 3
								else
									if (sym and 2) = 0 then
										' 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 
										j = 5
										big_sym = sym and 1
									end if
								end if
							end if
						end if
					end if
				end if
			end if
		else
			j = j - 1
			' get 6 bits
			if (sym and 192) = 128 then
				big_sym = (big_sym shl 6) + (sym and 63)
			end if
			if j = 0  then
				result = result + chr(big_sym and 255)
			end if
		end if
	next i
	
	utf8_translate = result
	
end function

function callback_agg_device_function(byref function_name as string, byref context_name as string, byref function_input as string, byref function_output as string) as ok_ng

	dim param as string
	dim channel as byte
	
	select case function_name
	case "init":
		if proc_device_op("I", "") = "A" then
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if
	case "reboot":
		if proc_device_op("R", "") = "A" then
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if
	case "si":
		channel = val(agg_record_decode(function_input, 0))
		if bp_ports(channel).enable = false then
			ser.num = channel
			if ser.enabled = NO then
				callback_agg_device_function = NG
				function_output = "Port disabled"
			else
				param = agg_record_decode(function_input, 1)
				
				param = utf8_translate(param)
				
				ser.setdata(param)
				ser.send()
				callback_agg_device_function = OK
			end if
		else
			callback_agg_device_function = NG
			function_output = "Port disabled"
		end if
		
	case "sao":		' Set Analog Output
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			if analog_set(channel, val(agg_record_decode(function_input, 1)), false) then
				callback_agg_device_function = OK
			else
				callback_agg_device_function = NG
			end if
		else
			callback_agg_device_function = NG
		end if

	case "gai":		' Get Analog Input
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			agg_record_encode(function_output, ftostr(analog_float_values(channel), FTOSTR_MODE_AUTO, 5))
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG 
		end if
		
	case "sdo":		' Set Digital Output
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 49 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			if io_set(channel, val(agg_record_decode(function_input, 1))) then
				callback_agg_device_function = OK
			else
				callback_agg_device_function = NG
			end if
		else
			callback_agg_device_function = NG
		end if

	case "gdi":		' Get Digital Input
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 49 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			agg_record_encode(function_output, str(param_io(channel).io_state))
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if

	case "spwm":	' Set PWM Values
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			if analog_pwm_set(channel, val(agg_record_decode(function_input, 1))) then
				callback_agg_device_function = OK
			else
				callback_agg_device_function = NG
			end if
		else
			callback_agg_device_function = NG
		end if

	case "spwme":	' Set PWM Enable
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			if analog_pwm_onoff(channel, val(agg_record_decode(function_input, 1))) then
				callback_agg_device_function = OK
			else
				callback_agg_device_function = NG
			end if
		else
			callback_agg_device_function = NG
		end if
		
	case "gpwme":	' Get PWN Enable
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			agg_record_encode(function_output, str(analog_pwm_enable(channel)))
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if

	case "gc":		' Get Counter
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 49 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			agg_record_encode(function_output, str(io_cn(channel).counter))
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if
	
	case "cc":		' Clear Counter
		channel = val(agg_record_decode(function_input, 0)) - 1
		#if PLATFORM_ID = TPP3WG2
		if channel >= 0 and channel < 48 then
		#endif
		#if PLATFORM_ID = TPP2WG2
		if channel >= 0 and channel < 24 then
		#endif
			io_cn(channel).counter = 0
			callback_agg_device_function = OK
		else
			callback_agg_device_function = NG
		end if
	
	case else:
		callback_agg_device_function = NG
	end select

end function

'------------------------------------------------------------------------------
sub callback_agg_rtc_sg(byref wdaycount as word, byref wmincount as word, byref bsec as byte, byref wmilsec as word, op as en_agg_rdwr)
	select case op
	case EN_AGG_GET:
		rtc.getdata(wdaycount,wmincount,bsec)
		wmilsec=0
	case EN_AGG_SET:
		rtc.setdata(wdaycount,wmincount,bsec)
	end select
end sub

'------------------------------------------------------------------------------
sub callback_agg_convert_table_field(byref table_name as string, byref field_name as string, byref field_value as string, op as en_agg_rdwr)
end sub

'------------------------------------------------------------------------------
function callback_agg_convert_setting(byref setting_name as string, index as byte, byref setting_value as string, op as en_agg_rdwr) as ok_ng
	
	callback_agg_convert_setting=OK
	device_stg_mod_sg(setting_name,index,setting_value,op)
	
end function

'------------------------------------------------------------------------------
sub callback_agg_synchronized()
	login_timeout_reset()
	agg_retry_counter=AGG_MAX_RETRY
end sub

'------------------------------------------------------------------------------
function callback_agg_get_firmware_version() as string
	callback_agg_get_firmware_version=FIRMWARE_VERSION
end function

'------------------------------------------------------------------------------
sub callback_agg_firmware_upload_progress(total_size as dword, remain_size as dword)

end sub

'------------------------------------------------------------------------------
sub ethernet_link_state_change(new_state as pl_net_linkstate)

	if new_state=PL_NET_LINKSTAT_NOLINK then
		'Ethernet is gone
		#if DEV_DEBUG_PRINT
			dev_debugprint("Ethernet FAILED")
		#endif
		interface_ready(PL_SOCK_INTERFACE_NET)=NO
		#if SUPPORTS_DISPLAY
			lcd_display_page(LCD_PAGE_NET, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		#endif
		
		'See if we can replace it with something...
		#if WLN_AVAILABLE
			if param_we<>WE_DISABLED then
				'Try to replace with Wi-Fi
				if param_we=WE_ENABLED_ONDEMAND and wln_already_started=NO then
					#if DEV_DEBUG_PRINT
						dev_debugprint("Start Wi-Fi")
					#endif
					num_wln_failures=0
					wln_result = wln_start(param_wa,param_ws,wln_password,PL_WLN_DOMAIN_FCC,no,PL_WLN_ASCAN_INFRASTRUCTURE)
					if wln_result <> WLN_STATUS_OK then
						#if DEV_DEBUG_PRINT
							dev_debugprint("Wi-Fi MALFUNCTIONED (could not start)")
						#endif
						wln_error=YES
					else
						wln_error=NO
						wln_already_started=YES
					end if
				end if
				
				if interface_ready(PL_SOCK_INTERFACE_WLN)=YES then
					change_current_interface(PL_SOCK_INTERFACE_WLN)
				end if
				#if SUPPORTS_DISPLAY
					lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
				#endif				
				
				'255 means Wi-Fi already fail and then we should allow GPRS to start (if enabled)
				if num_wln_failures<>255 and wln_error=NO then
					exit sub 
				end if
			end if
		#endif

		#if SUPPORTS_GPRS	
			if param_ge<>GE_DISABLED then
				'Try to replace with GPRS
				if param_ge=GE_ENABLED_ONDEMAND and gprs_already_started=NO then
					#if DEV_DEBUG_PRINT
						dev_debugprint("Start GPRS")
					#endif
					if gprs_start(param_ga,param_gn,param_gu,param_gp)<>GPRS_STATUS_OK then
						#if DEV_DEBUG_PRINT
							dev_debugprint("GPRS MALFUNCTIONED (could not start)")
						#endif
						gprs_error=YES
					else
						gprs_error=NO
						gprs_already_started=YES
					end if
				end if

				if interface_ready(PL_SOCK_INTERFACE_PPP)=YES then
					change_current_interface(PL_SOCK_INTERFACE_PPP)
				end if
			end if		
		#endif
	else	
		'Ethernet will be used from now on
		#if DEV_DEBUG_PRINT
			dev_debugprint("Ethernet OK")
		#endif
		interface_ready(PL_SOCK_INTERFACE_NET)=YES
		#if SUPPORTS_DISPLAY
			lcd_display_page(LCD_PAGE_NET, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		#endif

		#if WLN_AVAILABLE	
			'Stop Wi-Fi if it is in the on-demand mode 
			if param_we=WE_ENABLED_ONDEMAND then
				#if DEV_DEBUG_PRINT
					dev_debugprint("Stop Wi-Fi")
				#endif
				wln_stop()

				interface_ready(PL_SOCK_INTERFACE_WLN)=NO
				wln_already_started=NO
			end if
			#if SUPPORTS_DISPLAY
				lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
			#endif				
		#endif

		#if SUPPORTS_GPRS
			'Stop GPRS if it is in the on-demand mode
			if param_ge=GE_ENABLED_ONDEMAND and gprs_already_started=YES then
				#if DEV_DEBUG_PRINT
					dev_debugprint("Stop GPRS")
				#endif
				gprs_stop()
				interface_ready(PL_SOCK_INTERFACE_PPP)=NO
				gprs_already_started=NO
			end if
		#endif

		change_current_interface(PL_SOCK_INTERFACE_NET)
	end if
end sub

'------------------------------------------------------------------------------
sub close_interface_sockets(interface as pl_sock_interfaces)
	dim f,sock_num_bup as byte
	dim i as word
	
	sock_num_bup=sock.num
	
	for f=0 to sock.numofsock-1
		sock.num=f
		if sock.currentinterface=interface and sock.statesimple<>PL_SSTS_CLOSED then
			sock.discard
		end if
	next f

	i=sys.timercount

wait_close_interface_sockets:
	for f=0 to sock.numofsock-1
		sock.num=f
		if sock.currentinterface=interface and sock.statesimple<>PL_SSTS_CLOSED and sys.timercount-i<3 and sys.timercount>=i then
			goto wait_close_interface_sockets
		end if
	next f

	sock.num=sock_num_bup
end sub

'------------------------------------------------------------------------------
sub change_current_interface(new_interface as pl_sock_interfaces)
	if current_interface<>new_interface then
		'this will allow immediate logins on the new current interface
		
		if login_mode=CMD_MODE_AGGREGATE then
			agg_stop()
		end if
		
		if login_mode=CMD_MODE_HTTP or login_mode=CMD_MODE_UDP then
			login_mode=CMD_MODE_NONE
		end if
				
		sock.inconenabledmaster=NO
		close_interface_sockets(current_interface)

		current_interface=new_interface
		
		'receive UDP commands on the new current interface only
		sock.num=udp_sock
		select case current_interface
		case PL_SOCK_INTERFACE_NET: sock.allowedinterfaces="NET"
		#if WLN_AVAILABLE	
			case PL_SOCK_INTERFACE_WLN: sock.allowedinterfaces="WLN"
		#endif	
		case PL_SOCK_INTERFACE_PPP: sock.allowedinterfaces="PPP"
		end select		
		sock.inconenabledmaster=YES
				
		#if DEV_DEBUG_PRINT
			select case current_interface
			case PL_SOCK_INTERFACE_NET: dev_debugprint("Set current interface to Ethernet") 
			#if WLN_AVAILABLE	
				case PL_SOCK_INTERFACE_WLN: dev_debugprint("Set current interface to Wi-Fi")
			#endif	
			case PL_SOCK_INTERFACE_PPP: dev_debugprint("Set current interface to GPRS")
			end select
		#endif
	end if
end sub

'------------------------------------------------------------------------------
#if WLN_AVAILABLE
sub callback_wln_ok()

	#if DEV_DEBUG_PRINT
		dev_debugprint("Wi-Fi OK")
	#endif
	interface_ready(PL_SOCK_INTERFACE_WLN)=YES
	num_wln_failures=0

	'Should Wi-Fi become our current interface?
	if interface_ready(PL_SOCK_INTERFACE_NET)=NO then
		change_current_interface(PL_SOCK_INTERFACE_WLN)

		#if SUPPORTS_GPRS
			'Stop GPRS if it is in the on-demand mode
			if param_ge=GE_ENABLED_ONDEMAND and gprs_already_started=YES then
				#if DEV_DEBUG_PRINT
					dev_debugprint("Stop GPRS")
				#endif
				gprs_stop()
				interface_ready(PL_SOCK_INTERFACE_PPP)=NO
				gprs_already_started=NO
			end if
		#endif
	end if
	
	#if SUPPORTS_DISPLAY	
		if param_wd=NO then
			lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		end if	

		wln_dev_rescan_tmr=WLN_RESCAN_TMR_CTR
		if wln_network_state<>NETWORK_DHCP_IP_OBTAINED and wln_network_state<>NETWORK_DHCP_FIXED_IP then 
			lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		end if
	#endif
	
end sub

#endif

'------------------------------------------------------------------------------
#if WLN_AVAILABLE
sub callback_wln_failure(wln_state as en_wln_status_codes)
	dim new_state as en_network_states
	
	if num_wln_failures=255 then exit sub

	if num_wln_failures<MAX_NUM_WLN_FAILURES then
		num_wln_failures=num_wln_failures+1
	else
		num_wln_failures=255
		#if DEV_DEBUG_PRINT
			dev_debugprint("Wi-Fi FAILED")
		#endif
		interface_ready(PL_SOCK_INTERFACE_WLN)=NO

		#if SUPPORTS_GPRS	
			if param_ge<>GE_DISABLED and interface_ready(PL_SOCK_INTERFACE_NET)=NO then
				'Try to replace with GPRS
				if param_ge=GE_ENABLED_ONDEMAND and gprs_already_started=NO then
					#if DEV_DEBUG_PRINT
						dev_debugprint("Start GPRS")
					#endif
					if gprs_start(param_ga,param_gn,param_gu,param_gp)<>GPRS_STATUS_OK then
						#if DEV_DEBUG_PRINT
							dev_debugprint("GPRS MALFUNCTIONED (could not start)")
						#endif
						gprs_error=YES
					else
						gprs_error=NO
						gprs_already_started=YES
					end if
				end if

				if interface_ready(PL_SOCK_INTERFACE_PPP)=YES and interface_ready(PL_SOCK_INTERFACE_NET)=NO then
					change_current_interface(PL_SOCK_INTERFACE_PPP)
				end if
			end if		
		#endif		
	end if

	#if SUPPORTS_DISPLAY
		select case wln_state
		case WLN_STATUS_SCANNING_FAILURE:
			new_state=NETWORK_WLN_SCANNING_FAIL
		
		case WLN_STATUS_ASSOCIATION_FAILURE:
			new_state=NETWORK_WLN_ASSOCIATION_FAIL
		
		case WLN_STATUS_DISASSOCIATION:
			new_state=NETWORK_WLN_DISASSOCIATE
		
		case else:
			new_state=NETWORK_WLN_FATAL_ERROR
		
		end select
		
		lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
	#endif	
end sub

'------------------------------------------------------------------------------
sub callback_wln_mkey_progress_update(progress as byte)
	#if SUPPORTS_DISPLAY
	lcd_print_msg("Calculating... "+str(progress)+"%",0,lcd.height-lcd.fontheight*2,lcd.width,lcd.fontheight+2,PL_LCD_TEXT_ALIGNMENT_TOP_CENTER,NO)
	#endif
end sub


'------------------------------------------------------------------------------
sub callback_wln_pre_buffrq(required_buff_pages as byte)
end sub


'------------------------------------------------------------------------------
sub callback_wln_rescan_result(current_rssi as byte, scan_rssi as byte, different_ap as no_yes)
	dim x,f as byte
	dim s1, s2, s3, s4 as string(32)
	
	wln_rescanning=NO
	
	if different_ap=NO then
		goto reprint_ip
	end if
	
	if scan_rssi<current_rssi then
		goto reprint_ip
	end if
	
	if scan_rssi-current_rssi<5 then
reprint_ip:	
		#if SUPPORTS_DISPLAY
			lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		#endif
		
		exit sub
	end if
	
	x=val(stg_get("WE",0))
	s1=stg_get("WA",0)
	
	select case x
	case WLN_SECURITY_MODE_DISABLED:
		s2=""
	case WLN_SECURITY_MODE_WEP64,WLN_SECURITY_MODE_WEP128:
		s2=stg_get("WP",0)
		
		if x=WLN_SECURITY_MODE_WEP64 and len(s2)=5 then
			s4=""
			for f=1 to 5
				s3=mid(s2,f,1)
				s3=hex(asc(s3))
				s3=right(s3,len(s3)-2)
				if len(s3)<2 then s3="0"+s3
				s4=s4+s3
			next f
			s2=s4
		end if
		
		if x=WLN_SECURITY_MODE_WEP128 and len(s2)=13 then
			s4=""
			for f=1 to 13
				s3=mid(s2,f,1)
				s3=hex(asc(s3))
				s3=right(s3,len(s3)-2)
				if len(s3)<2 then s3="0"+s3
				s4=s4+s3
			next f
			s2=s4
		end if
			
	case else:
		s2=stg_get("WK",0)
	end select
	
	wln_want_to_change_ap=YES
	wln_change(s1,x,s2) 'this could fail but we don't care

end sub

'----------------------------------------------------------------------------
sub callback_wln_starting_association()
	#if SUPPORTS_DISPLAY 
		lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
	#endif
end sub

'------------------------------------------------------------------------------
sub callback_wln_rescan_for_better_ap()

end sub

'------------------------------------------------------------------------------
public sub device_update_rssi()
	if wln_check_association()<>WLN_ASSOCIATION_RETVAL_YES then exit sub
	rssi_update_timer=rssi_update_timer-1
	if rssi_update_timer=0 then
		wln_update_rssi()
		rssi_update_timer=RSSI_UPDATE_TIMER_CTR
	end if
	
end sub

'------------------------------------------------------------------------------
public sub device_check_for_better_ap()
	if wln_check_association()<>WLN_ASSOCIATION_RETVAL_YES then
		wln_dev_rescan_tmr=WLN_RESCAN_TMR_CTR
	else
		'when we are associated...
		if wln_dev_rescan_tmr>0 then
			wln_dev_rescan_tmr=wln_dev_rescan_tmr-1
			if wln_dev_rescan_tmr=0 then
				sock.num=agg_sock
				if sock.statesimple=PL_SSTS_EST then
					wln_dev_rescan_tmr=WLN_RESCAN_TMR_CTR
					if wln.rssi>=WLN_RSSI_1 then
						exit sub
					else
						goto rescan 'if TCP established we rescan only if current signal is weak
					end if
				else	
					wln_dev_rescan_tmr=WLN_RESCAN_TMR_CTR2
rescan:				wln_rescanning=YES
					#if SUPPORTS_DISPLAY
						lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
					#endif
					wln_start_rescan() 'if TCP not established we rescan periodically no matter whata
				end if
			end if
		end if
	end if
end sub

#endif

'---------------------------------------------------------------------------------------------------
#if WLN_AVAILABLE and SUPPORTS_DISPLAY

function get_ap_name() as string
	get_ap_name=stg_get("WA",0)
	
	if len(get_ap_name)>9 then
		get_ap_name=left(get_ap_name,8)
		get_ap_name=get_ap_name+"."
	end if
end function

#endif
'----------------------------------------------------------------------------

#if SUPPORTS_DISPLAY
'----------------------------------------------------------------------------
public sub print_wifi()
	dim icon as byte
	dim s as string(8)

	if enter_menu=YES then exit sub
	
	#if WLN_AVAILABLE
		if wln.enabled=YES then
			select case wln_network_state
			case NETWORK_WLN_DISABLED:
				exit sub
				
			case NETWORK_DHCP_FIXED_IP, NETWORK_DHCP_OBTAINING_IP, NETWORK_DHCP_FAIL_OBTAINING_IP, NETWORK_DHCP_IP_OBTAINED, NETWORK_WLN_JOINED:
				if wln.rssi<WLN_RSSI_1 then
					icon=0
				end if
				if wln.rssi<WLN_RSSI_2 and wln.rssi>=WLN_RSSI_1 then
					icon=1
				end if
				if wln.rssi<WLN_RSSI_3 and wln.rssi>=WLN_RSSI_2 then
					icon=2
				end if		
				if wln.rssi<WLN_RSSI_4 and wln.rssi>=WLN_RSSI_3 then
					icon=3
				end if
				if wln.rssi>=WLN_RSSI_4 then
					icon=4
				end if
				
			case NETWORK_WLN_SCANNING_FAIL, NETWORK_WLN_JOINING:
				icon=5	

			case NETWORK_WLN_DISASSOCIATE, NETWORK_WLN_ASSOCIATION_FAIL:
				icon=6
				
			case NETWORK_WLN_INVALID_WKEY:
				icon=8
				
			case else
				icon=7

			end select
		else
			icon=7
		end if
	#else
		icon=7
	#endif
	
	if icon<>prev_icon then
		romfile.open("wifi.bmp")
		lcd.bmp(romfile.offset,78,0,icon*24,0,24,18)
		prev_icon=icon
	end if

	romfile.open("Tibbo-5x7(V).bin")
	lcd.setfont(romfile.offset)
	lcd.texthorizontalspacing=1
	lcd.forecolor=TXT_GRAY
	lcd.backcolor=LCD_BACKCOLOR
	
	select case login_mode
	
	case CMD_MODE_AGGREGATE:
		s="AGG"
		lcd.print(s,107,1)
		sock.num=agg_sock
		select case sock.statesimple
		case PL_SSTS_CLOSED:
			select case sock.state
			case PL_SST_CL_PCLOSED,PL_SST_CL_PRESET_POPENING, PL_SST_CL_PRESET_AOPENING,
			PL_SST_CL_PRESET_EST,PL_SST_CL_PRESET_PCLOSING,PL_SST_CL_PRESET_ACLOSING,
			PL_SST_CL_PRESET_STRANGE,PL_SST_PC:
				s="XXXX"
			case else:
				s="----"
			end select
				
		case PL_SSTS_ARP:
			s="O)))"
		
		case PL_SSTS_PO,PL_SSTS_AO:
			s="O==>"
		
		case PL_SSTS_EST:		
			if agg_cmd_received=YES then
				agg_cmd_received=NO
				agg_cmd_progress=agg_cmd_progress+1
				if agg_cmd_progress>3 then agg_cmd_progress=0
				select case agg_cmd_progress
				case 0:s=">==="
				case 1:s="=>=="
				case 2:s="==>="
				case 3:s="===>"
				end select
			else
				s="===="
			end if	
		end select	
		lcd.print(s,107,11)		
		
	case CMD_MODE_HTTP:
		s="HTML"
		lcd.print(s,107,1)
		s="===="
		lcd.print(s,107,11)
	case else
		s="    "
		lcd.print(s,107,1)
		s="----"
		lcd.print(s,107,11)
	end select
end sub

#endif
'------------------------------------------------------------------------------
sub callback_gprs_ok()
	
	#if DEV_DEBUG_PRINT
		dev_debugprint("GPRS OK")
	#endif
	interface_ready(PL_SOCK_INTERFACE_PPP)=YES

	'Should GPRS become our current interface?
	#if WLN_AVAILABLE
		if interface_ready(PL_SOCK_INTERFACE_NET)=NO and interface_ready(PL_SOCK_INTERFACE_WLN)=NO then
			change_current_interface(PL_SOCK_INTERFACE_PPP)
		end if
	#else
		if interface_ready(PL_SOCK_INTERFACE_NET)=NO then
			change_current_interface(PL_SOCK_INTERFACE_PPP)
		end if
	#endif

end sub

'------------------------------------------------------------------------------
sub callback_gprs_failure()
	#if DEV_DEBUG_PRINT
		dev_debugprint("GPRS FAILED")
	#endif
	if login_mode=CMD_MODE_AGGREGATE and current_interface=PL_SOCK_INTERFACE_PPP then
		agg_stop()
	end if
		
end sub

'------------------------------------------------------------------------------
sub callback_gprs_pre_buffrq(required_buff_pages as byte)
end sub

'------------------------------------------------------------------------------
sub callback_dhcp_ok(renew as no_yes, interface as pl_sock_interfaces, byref ip as string, byref gateway_ip as string, byref netmask as string, lease_time as dword)
	
	if interface=PL_SOCK_INTERFACE_NET then
		if renew=YES and net.ip<>ip then
			'this is a lease renewal and the DHCP server has issues new IP
			'it is better to reboot than deal with the implications of the changed IP
			sys.reboot
		end if

		dhcp_failed(0) = NO
		
		#if DEV_DEBUG_PRINT
			dev_debugprint("Ethernet DHCP OK ("+ip+")")
		#endif

		if net.ip<>ip then
			sock.inconenabledmaster=NO
			close_interface_sockets(PL_SOCK_INTERFACE_NET)
			net.ip=ip
			net.gatewayip=gateway_ip
			net.netmask=netmask
			sock.inconenabledmaster=YES

			if stg_get("IP",0)<>ip then
				stg_set("IP",0,ip)
			end if
			if stg_get("GI",0)<>gateway_ip then
				stg_set("GI",0,gateway_ip)
			end if
			if stg_get("NM",0)<>netmask then
				stg_set("NM",0,netmask)
			end if
		end if
		declare_ip_obtained(PL_SOCK_INTERFACE_NET)
		#if SUPPORTS_DISPLAY
			lcd_display_page(LCD_PAGE_NET, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		#endif		
	end if

	#if WLN_AVAILABLE	
		if interface=PL_SOCK_INTERFACE_WLN then
			if renew=YES and wln.ip<>ip then
				'this is a lease renewal and the DHCP server has issues new IP
				'it is better to reboot than deal with the implications of the changed IP
				sys.reboot
			end if
			
			dhcp_failed(1) = NO
			
			#if DEV_DEBUG_PRINT
				dev_debugprint("Wi-Fi DHCP OK ("+ip+")")
			#endif
			
			if wln.ip<>ip then
				sock.inconenabledmaster=NO
				close_interface_sockets(PL_SOCK_INTERFACE_WLN)
				wln.ip=ip
				wln.gatewayip=gateway_ip
				wln.netmask=netmask
				sock.inconenabledmaster=YES
				
				if stg_get("WI",0)<>ip then
					stg_set("WI",0,ip)
				end if
				if stg_get("WG",0)<>gateway_ip then
					stg_set("WG",0,gateway_ip)
				end if
				if stg_get("WN",0)<>netmask then
					stg_set("WN",0,netmask)
				end if
			end if
			declare_ip_obtained(PL_SOCK_INTERFACE_WLN)
			#if SUPPORTS_DISPLAY
				lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
			#endif			
		end if

	#endif

	ip_configured(interface)=YES
end sub

'------------------------------------------------------------------------------
sub callback_dhcp_failure(interface as pl_sock_interfaces,failure_code as en_dhcp_status_codes)
	
	sock.inconenabledmaster=NO
	close_interface_sockets(interface)
	if interface=PL_SOCK_INTERFACE_NET then
		#if DEV_DEBUG_PRINT
			dev_debugprint("Ethernet DHCP FAILED")
		#endif
		dhcp_failed(0) = YES
		net.ip=validate_ip(stg_get("IP",0))
		declare_ip_set(PL_SOCK_INTERFACE_NET)
		#if SUPPORTS_DISPLAY
			lcd_display_page(LCD_PAGE_NET, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		#endif		
	else
		#if WLN_AVAILABLE	
			#if DEV_DEBUG_PRINT
				dev_debugprint("Wi-Fi DHCP FAILED")
			#endif
			dhcp_failed(1) = YES
			wln.ip=validate_ip(stg_get("WI",0))
			declare_ip_set(PL_SOCK_INTERFACE_WLN)
			#if SUPPORTS_DISPLAY
				lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
			#endif
		#endif
	end if
	sock.inconenabledmaster=YES
	ip_configured(interface)=YES	
end sub

'------------------------------------------------------------------------------
sub callback_dhcp_pre_clear_ip(interface as pl_sock_interfaces)
	ip_configured(interface)=NO
	close_interface_sockets(interface)

	#if SUPPORTS_DISPLAY
		if interface=PL_SOCK_INTERFACE_NET then
			lcd_display_page(LCD_PAGE_NET, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		end if
	#endif
	
	#if WLN_AVAILABLE and SUPPORTS_DISPLAY
		if interface=PL_SOCK_INTERFACE_WLN then		
			lcd_display_page(LCD_PAGE_WLN, LCD_PRINT_MODE_GENTLE, LCD_PRINT_ELEMENT_ALL)
		end if
	#endif
end sub

'------------------------------------------------------------------------------
sub callback_dhcp_pre_buffrq(required_buff_pages as byte)
	http_buff_rq(HTTP_BUFF_DISALLOCATE)
end sub

'------------------------------------------------------------------------------
sub callback_dhcp_buff_released()
	if http_buff_rq(HTTP_BUFF_ALLOCATE)<>OK then
		'insufficient memory
	end if
end sub

'------------------------------------------------------------------------------
sub callback_stg_error(byref stg_name_or_num as string,index as byte,status as en_stg_status_codes)
	declare_error_mode()
end sub

'------------------------------------------------------------------------------
sub callback_stg_pre_get(byref stg_name_or_num as string,index as byte,byref stg_value as string)

end sub

'------------------------------------------------------------------------------
sub callback_stg_post_set(byref stg_name_or_num as string, index as byte,byref stg_value as string)
	dim s as string(2)
	dim b as byte
	
	rtc.getdata(stg_timestamp.ts_daycount,stg_timestamp.ts_mincount,stg_timestamp.ts_seconds)
	stg_timestamp.ts_milsec=999
	stg_set_ts(stg_name_or_num)

	if index=255 then exit sub
	
	select case stg_name_or_num
	case "AR":
		param_ar=val(stg_value)
	case "SE":
		param_se(index)=val(stg_value)
		if param_se(index)=1 then
			'init_serial_ports()
		else	
			ser.num=index
			ser.enabled=no
			for b=0 to NUM_OF_IO-1
				io.num=index_to_io_num(b)
				io.enabled= YES '(b).io_enabled
				if param_io(b).io_enabled=1 and param_io(b).io_output=1 then
					io.state=LOW
				else
					io.state=HIGH
				end if

			next b
		end if
'		#if SUPPORTS_DISPLAY		
'			print_io_screen(index*4,NO)
'			print_io_screen(index*4+1,NO)
'			print_io_screen(index*4+2,NO)
'			print_io_screen(index*4+3,NO)
'		#endif
	case "FC":
		param_fc(index)=val(stg_value)
		'init_serial_ports()
		
		select case index
		case 0:io.num=PL_IO_NUM_0
		case 1:io.num=PL_IO_NUM_1
		case 2:io.num=PL_IO_NUM_2
		case 3:io.num=PL_IO_NUM_3
		case else:
		end select
		b=io_num_to_index(io.num)
		if io.enabled=YES and param_io(b).io_output=1 then
			io.state=LOW
		else
			io.state=HIGH
		end if
'		#if SUPPORTS_DISPLAY		
'			print_io_screen(index*4+2,NO)
'			print_io_screen(index*4+3,NO)
'		#endif		
		select case index
		case 0:io.num=PL_IO_NUM_16_INT0
		case 1:io.num=PL_IO_NUM_17_INT1
		case 2:io.num=PL_IO_NUM_18_INT2
		case 3:io.num=PL_IO_NUM_19_INT3
		case else:
		end select
		b=io_num_to_index(io.num)
		if io.enabled=YES and param_io(b).io_output=1 then
			io.state=LOW
		else
			io.state=HIGH
		end if
'		#if SUPPORTS_DISPLAY
'			print_io_screen(b,NO)
'		#endif		
	case "BR":
		param_br(index)=val(stg_value)
		'init_serial_ports()
	case "PR":
		param_pr(index)=val(stg_value)
		'init_serial_ports()
	case "BB":
		param_bb(index)=val(stg_value)
		'init_serial_ports()
		
#if USE_DNS		
	case "TN":
		server_ip_obtain=NO
		if login_mode=CMD_MODE_AGGREGATE then
			agg_stop()
		end if
#endif
	case else:
		if left(stg_name_or_num,1)="I" then
			s=mid(stg_name_or_num,2,2)
			b=asc(s)
			if b>47 and b<58 then
				b=val(s)
				if index=0 then
					param_io(b).io_enabled=val(stg_value)
					io.num=index_to_io_num(b)
					io.enabled=param_io(b).io_enabled
					if io.enabled=YES then
						if param_io(b).io_output=1 then
							io.state=LOW
						else
							io.state=HIGH
						end if
					end if					
				else
					param_io(b).io_output=val(stg_value)
					io.num=index_to_io_num(b)
					if param_io(b).io_enabled=1 and param_io(b).io_output=1 then
						io.state=LOW
					else
						io.state=HIGH
					end if
				end if
			end if
		end if
	end select
	
end sub

'------------------------------------------------------------------------------
sub callback_html_stg_mod_sg(byref setting_name as string, index as byte, byref setting_value as string, op as en_stg_rdwr)

end sub

'------------------------------------------------------------------------------
sub callback_sntp_failure(sntp_status as en_sntp_status_codes)

end sub

'------------------------------------------------------------------------------
sub callback_sntp_ok(byref w_days as word,byref w_mins as word,byref b_seconds as byte)
	rtc.setdata(w_days,w_mins,b_seconds)
	last_sntp_date=w_days
	
end sub

'------------------------------------------------------------------------------
sub callback_sntp_pre_buffrq(required_buff_pages as byte)

end sub

'------------------------------------------------------------------------------
public function proc_device_op(byref param1 as string, byref param2 as string) as string(1)

	select case param1
	case "I":
		select case device_setting_init(EN_STG_INIT_MODE_NORMAL)
		case ok:
			proc_device_op="A"
		case else:
			proc_device_op="E"
			exit function
		end select
	case "R":
		proc_device_op="A"
		reboot_flag=YES
		reboot_timer=6
	end select
end function

'------------------------------------------------------------------------------
public sub device_setting_set(sname as string(STG_MAX_SETTING_NAME_LEN), index as byte, byref s as string)
	'********** ADDITIONAL CODE MAY BE NEEDED **********

end sub

'------------------------------------------------------------------------------
public function device_setting_check(byref setting_name as string,byref setting_val as string) as ok_ng
	'********** ADDITIONAL CODE MAY BE NEEDED **********
	device_setting_check = OK
end function 

'------------------------------------------------------------------------------
public sub device_login_event(mode as cmd_modes)

end sub

'------------------------------------------------------------------------------
public function device_get_timeout(mode as cmd_modes) as word
	if mode=CMD_MODE_AGGREGATE then
		device_get_timeout=0
	else
		device_get_timeout=LOGIN_TIMEOUT
	end if
end function

'------------------------------------------------------------------------------
#if DEV_DEBUG_PRINT
sub dev_debugprint(byref print_data as string)
	sys.debugprint(DEV_STAMP + print_data + CR_LF)
end sub
#endif

'------------------------------------------------------------------------------
function validate_ip(byref ip as string) as string
	dim x as byte
	
	validate_ip=ddval(ip)
	
	'first number can't be 0 or >223
	x=asc(left(validate_ip,1))
	if x=0 or x>223 then
		insert(validate_ip,1,chr(1))
	end if
	
	'last number can't be 0 or 255
	x=asc(right(validate_ip,1))
	if x=0 or x=255 then
		insert(validate_ip,4,chr(1))
	end if

	validate_ip=ddstr(validate_ip)
end function

'------------------------------------------------------------------------------
#if SIGNAL_STRENGTH_INDICATION=1
sub signal_strength_indication_init()
	dim f as byte
	
	'make sure there is no reset
	io.num=SIGNAL_STRENGTH_CLR
	io.enabled=YES
	io.state=HIGH

	'we will be turning LEDs off
	io.num=SIGNAL_STRENGTH_DATA
	io.enabled=YES
	io.state=HIGH
	'make 5 clocks
	io.num=SIGNAL_STRENGTH_CK
	io.enabled=YES
	for f=0 to 4
		io.state=LOW
		io.state=HIGH
	next f
end sub
#endif	

'------------------------------------------------------------------------------
#if SIGNAL_STRENGTH_INDICATION=1
sub signal_strength_set(strength as byte)
'Bits 0-5 of strength argument correspond to LEDs	
	
	dim f,x as byte
	dim s as string(8)
	
	s=mid(bin(strength),3,8)
	s=strgen(8-len(s),"0")+s	
	
	'make 5 clocks
	io.num=SIGNAL_STRENGTH_CK
	for f=0 to 4
		x=1-val(mid(s,f+4,1))
		io.lineset(SIGNAL_STRENGTH_DATA,x)
		io.state=LOW
		io.state=HIGH
	next f
end sub
#endif	

'------------------------------------------------------------------------------
sub device_stg_mod_sg(byref stg_name as string, index as byte, byref stg_val as string, op as en_stg_rdwr)

end sub

'------------------------------------------------------------------------------
public function http_buff_rq(op as en_http_buff_allocate) as ok_ng
	dim f as byte
	
	http_buff_rq=OK
	if op=HTTP_BUFF_ALLOCATE then
		f=(SOCK_HTTP_TXBUFF_SIZE+1)*NUM_HTTP_SOCKETS
		if sys.freebuffpages<f then
			http_buff_rq=NG
			exit function
		end if
		for f=0 to NUM_HTTP_SOCKETS-1
			sock.num=sock_http(f)
			sock.redir(PL_REDIR_SOCK0+sock_http(f))
			sock.txbuffrq(SOCK_HTTP_TXBUFF_SIZE)
			sock.varbuffrq(7)
		next f
	else
		for f=0 to NUM_HTTP_SOCKETS-1
			sock.num=sock_http(f)
			sock.txbuffrq(0)
			sock.varbuffrq(0)
		next f	
	end if
	sys.buffalloc
end function

'------------------------------------------------------------------------------
public sub html_pre_login()
	dim b as byte
	if login_mode=CMD_MODE_AGGREGATE then
		b=sock.num
		agg_stop()
		sock.num=b
		prev_login_mode=CMD_MODE_AGGREGATE
	end if
end sub

'------------------------------------------------------------------------------
public function device_setting_init(init_mode as en_stg_init_modes) as ok_ng
	#if SUPPORTS_DISPLAY
		'turn on backlight
		io.num=PL_IO_NUM_54 
		io.state=LOW	
		romfile.open(LCD_STD_FONT)
		lcd.setfont(romfile.offset)	
		lcd.forecolor=LCD_FORECOLOR
		lcd.backcolor=LCD_BACKCOLOR
		lcd_clear(40,30,240,180)
		lcd_print_msg("Invalid settings detected.`Initializing...",40,30,240,180,PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER,YES)
	#endif
	pat.play(PAT_BOTH_OFF,PL_PAT_CANINT)
	if stg_restore_multiple(init_mode)<>EN_STG_STATUS_OK then
		pat.play(PAT_LONG_RED,PL_PAT_CANINT)
		beep.play(BEEP_LONG,PL_BEEP_CANINT)
		device_setting_init=NG
	else
		pat.play(PAT_LONG_GREEN,PL_PAT_CANINT)
		beep.play(BEEP_SHORT,PL_BEEP_CANINT)
		device_setting_init=OK
	end if

end function

'------------------------------------------------------------------------------
public sub device_process_esc_seq(byref s as string)
	dim pos,x as byte
	
	'process escape sequences
	pos=instr(1,s,"\x5Cx",1) 'we are searching for "\x"
	while pos>0
		x=val("&h"+mid(s,pos+2,2))
		s=mid(s,1,pos-1)+chr(x)+mid(s,pos+4,255)
		pos=instr(1,s,"\x5C",1)
	wend
end sub

'------------------------------------------------------------------------------
public function index_to_io_num(index as byte) as pl_io_num
	select case index
#if PLATFORM_ID = TPP3WG2
	'S1
	case 0:index_to_io_num=pl_io_num_9_tx0
	case 1:index_to_io_num=pl_io_num_8_rx0
	case 2:index_to_io_num=pl_io_num_0
	case 3:index_to_io_num=pl_io_num_16_int0
	'S3
	case 4:index_to_io_num=pl_io_num_32
	case 5:index_to_io_num=pl_io_num_33
	case 6:index_to_io_num=pl_io_num_4
	case 7:index_to_io_num=pl_io_num_20_int4
	'S5
	case 8:index_to_io_num=pl_io_num_11_tx1
	case 9:index_to_io_num=pl_io_num_10_rx1
	case 10:index_to_io_num=pl_io_num_1
	case 11:index_to_io_num=pl_io_num_17_int1
	'S7
	case 12:index_to_io_num=pl_io_num_34
	case 13:index_to_io_num=pl_io_num_35
	case 14:index_to_io_num=pl_io_num_5
	case 15:index_to_io_num=pl_io_num_21_int5
	'S9
	case 16:index_to_io_num=pl_io_num_13_tx2
	case 17:index_to_io_num=pl_io_num_12_rx2
	case 18:index_to_io_num=pl_io_num_2
	case 19:index_to_io_num=pl_io_num_18_int2
	'S11
	case 20:index_to_io_num=pl_io_num_36
	case 21:index_to_io_num=pl_io_num_37
	case 22:index_to_io_num=pl_io_num_6
	case 23:index_to_io_num=pl_io_num_22_int6
	'S13
	case 24:index_to_io_num=pl_io_num_15_tx3
	case 25:index_to_io_num=pl_io_num_14_rx3
	case 26:index_to_io_num=pl_io_num_3
	case 27:index_to_io_num=pl_io_num_19_int3
	'S15
	case 28:index_to_io_num=pl_io_num_38
	case 29:index_to_io_num=pl_io_num_39
	case 30:index_to_io_num=pl_io_num_7
	case 31:index_to_io_num=pl_io_num_23_int7
	'S17
	case 32:index_to_io_num=pl_io_num_24
	case 33:index_to_io_num=pl_io_num_25
	case 34:index_to_io_num=pl_io_num_26
	case 35:index_to_io_num=pl_io_num_27
	'S19
	case 36:index_to_io_num=pl_io_num_28
	case 37:index_to_io_num=pl_io_num_29
	case 38:index_to_io_num=pl_io_num_30
	case 39:index_to_io_num=pl_io_num_31
	'S21
	case 40:index_to_io_num=pl_io_num_40
	case 41:index_to_io_num=pl_io_num_41
	case 42:index_to_io_num=pl_io_num_42
	case 43:index_to_io_num=pl_io_num_43
	'S23
	case 44:index_to_io_num=pl_io_num_54
	case 45:index_to_io_num=pl_io_num_55
	'S25
	case 46:index_to_io_num=pl_io_num_44
#endif		
#if PLATFORM_ID = TPP2WG2
	'S1
	case 0:index_to_io_num=pl_io_num_9_tx0
	case 1:index_to_io_num=pl_io_num_8_rx0
	case 2:index_to_io_num=pl_io_num_0
	case 3:index_to_io_num=pl_io_num_16_int0
	'S3
	case 4:index_to_io_num=pl_io_num_11_tx1
	case 5:index_to_io_num=pl_io_num_10_rx1
	case 6:index_to_io_num=pl_io_num_1
	case 7:index_to_io_num=pl_io_num_17_int1
	'S5
	case 8:index_to_io_num=pl_io_num_13_tx2
	case 9:index_to_io_num=pl_io_num_12_rx2
	case 10:index_to_io_num=pl_io_num_2
	case 11:index_to_io_num=pl_io_num_18_int2
	'S7
	case 12:index_to_io_num=pl_io_num_15_tx3
	case 13:index_to_io_num=pl_io_num_14_rx3
	case 14:index_to_io_num=pl_io_num_3
	case 15:index_to_io_num=pl_io_num_19_int3
	'S9
	case 16:index_to_io_num=pl_io_num_32
	case 17:index_to_io_num=pl_io_num_33
	case 18:index_to_io_num=pl_io_num_4
	case 19:index_to_io_num=pl_io_num_20_int4
	'S11
	case 20:index_to_io_num=pl_io_num_34
	case 21:index_to_io_num=pl_io_num_35
	case 22:index_to_io_num=pl_io_num_5
	case 23:index_to_io_num=pl_io_num_21_int5
	
#endif		
	case else:

	end select
end function

'------------------------------------------------------------------------------
public function io_num_to_index(io_num as pl_io_num) as byte
	select case io_num
	#if PLATFORM_ID=TPP3W or PLATFORM_ID=TPP3WG2
	'S1
	case pl_io_num_9_tx0:io_num_to_index=0
	case pl_io_num_8_rx0:io_num_to_index=1
	case pl_io_num_0:io_num_to_index=2
	case pl_io_num_16_int0:io_num_to_index=3
	'S3
	case pl_io_num_32:io_num_to_index=4
	case pl_io_num_33:io_num_to_index=5
	case pl_io_num_4:io_num_to_index=6
	case pl_io_num_20_int4:io_num_to_index=7
	'S5
	case pl_io_num_11_tx1:io_num_to_index=8
	case pl_io_num_10_rx1:io_num_to_index=9
	case pl_io_num_1:io_num_to_index=10
	case pl_io_num_17_int1:io_num_to_index=11
	'S7
	case pl_io_num_34:io_num_to_index=12
	case pl_io_num_35:io_num_to_index=13
	case pl_io_num_5:io_num_to_index=14
	case pl_io_num_21_int5:io_num_to_index=15
	'S9
	case pl_io_num_13_tx2:io_num_to_index=16
	case pl_io_num_12_rx2:io_num_to_index=17
	case pl_io_num_2:io_num_to_index=18
	case pl_io_num_18_int2:io_num_to_index=19
	'S11
	case pl_io_num_36:io_num_to_index=20
	case pl_io_num_37:io_num_to_index=21
	case pl_io_num_6:io_num_to_index=22
	case pl_io_num_22_int6:io_num_to_index=23
	'S13
	case pl_io_num_15_tx3:io_num_to_index=24
	case pl_io_num_14_rx3:io_num_to_index=25
	case pl_io_num_3:io_num_to_index=26
	case pl_io_num_19_int3:io_num_to_index=27
	'S15
	case pl_io_num_38:io_num_to_index=28
	case pl_io_num_39:io_num_to_index=29
	case pl_io_num_7:io_num_to_index=30
	case pl_io_num_23_int7:io_num_to_index=31
	'S17
	case pl_io_num_24:io_num_to_index=32
	case pl_io_num_25:io_num_to_index=33
	case pl_io_num_26:io_num_to_index=34
	case pl_io_num_27:io_num_to_index=35
	'S19
	case pl_io_num_28:io_num_to_index=36
	case pl_io_num_29:io_num_to_index=37
	case pl_io_num_30:io_num_to_index=38
	case pl_io_num_31:io_num_to_index=39
	'S21
	case pl_io_num_40:io_num_to_index=40
	case pl_io_num_41:io_num_to_index=41
	case pl_io_num_42:io_num_to_index=42
	case pl_io_num_43:io_num_to_index=43
	'S23
	case pl_io_num_54:io_num_to_index=44
	case pl_io_num_55:io_num_to_index=45
	'S25
	case pl_io_num_44:io_num_to_index=46
#endif		
#if PLATFORM_ID=TPP2W or PLATFORM_ID=TPP2WG2
	'S1
	case pl_io_num_9_tx0:io_num_to_index=0
	case pl_io_num_8_rx0:io_num_to_index=1
	case pl_io_num_0:io_num_to_index=2
	case pl_io_num_16_int0:io_num_to_index=3
	'S3
	case pl_io_num_11_tx1:io_num_to_index=4
	case pl_io_num_10_rx1:io_num_to_index=5
	case pl_io_num_1:io_num_to_index=6
	case pl_io_num_17_int1:io_num_to_index=7
	'S5
	case pl_io_num_13_tx2:io_num_to_index=8
	case pl_io_num_12_rx2:io_num_to_index=9
	case pl_io_num_2:io_num_to_index=10
	case pl_io_num_18_int2:io_num_to_index=11
	'S7
	case pl_io_num_15_tx3:io_num_to_index=12
	case pl_io_num_14_rx3:io_num_to_index=13
	case pl_io_num_3:io_num_to_index=14
	case pl_io_num_19_int3:io_num_to_index=15
	'S9
	case pl_io_num_32:io_num_to_index=16
	case pl_io_num_33:io_num_to_index=17
	case pl_io_num_4:io_num_to_index=18
	case pl_io_num_20_int4:io_num_to_index=19
	'S11
	case pl_io_num_34:io_num_to_index=20
	case pl_io_num_35:io_num_to_index=21
	case pl_io_num_5:io_num_to_index=22
	case pl_io_num_21_int5:io_num_to_index=23
#endif
	case else:
		
	end select	
end function

'------------------------------------------------------------------------------
public sub set_net_ip(interface as pl_sock_interfaces)
'Correctly sets new IP for use (from the IP setting)
	dim s as string(16)
	dim x,f as byte
	
	if interface=PL_SOCK_INTERFACE_NET then
		s=stg_get("IP",0)
		declare_ip_set(PL_SOCK_INTERFACE_NET)
	end if

	if interface=PL_SOCK_INTERFACE_WLN then
		s=stg_get("WI",0)
		declare_ip_set(PL_SOCK_INTERFACE_WLN)
	end if
	
	s=ddval(s)
	
	'first number can't be 0 or >223
	x=asc(left(s,1))
	if x=0 or x>223 then
		s=right(s,3)
		s=chr(1)+s
	end if
	
	'last number can't be 0 or 255
	x=asc(right(s,1))
	if x=0 or x=255 then
		s=left(s,3)+chr(1)
	end if
	
	'shut all sockets!
	sock.inconenabledmaster=NO 
	for f=0 to sock.numofsock-1
		sock.num=f
		sock.discard
		while sock.statesimple<>PL_SSTS_CLOSED
		wend
	next f
	
	'change the IP
	if interface=PL_SOCK_INTERFACE_NET then
		net.ip=ddstr(s)
		net.netmask=stg_get("NM",0)
		net.gatewayip=stg_get("GI",0)
		sock.inconenabledmaster=YES 
	end if
#if WLN_AVAILABLE	
	if interface=PL_SOCK_INTERFACE_WLN then
		wln.ip=ddstr(s)
		wln.netmask=stg_get("WN",0)
		wln.gatewayip=stg_get("WG",0)
		sock.inconenabledmaster=YES
	end if
#endif

end sub

'------------------------------------------------------------------------------
#if USE_DNS
sub callback_dns_failure(status as en_dns_status_codes)
	server_ip_obtain=YES
end sub

'------------------------------------------------------------------------------
sub callback_dns_answer_acquired(return_type as en_dns_return_type, byref return_string as string)
	dim s as string(32)
	
	if server_ip_obtain=NO and return_type=EN_DNS_RET_IP then
		s=ddstr(return_string)
		stg_set("TI",0,s)
		server_ip_obtain=YES
	end if
	sock.close()
end sub

'------------------------------------------------------------------------------
sub callback_dns_ok()
end sub

'------------------------------------------------------------------------------
sub callback_dns_pre_buffrq(num_of_pages_required as byte)
end sub

'------------------------------------------------------------------------------
sub callback_dns_buff_released()
end sub

#endif

'------------------------------------------------------------------------------
public function device_settings_sg(setting_name as string(5),index as byte, byref setting_val as string, byref stg_num as byte, rw as en_device_rdwr) as en_stg_status_codes
	dim w1, w2, w3 as word
	dim b1, b2, b3, b4 as byte
	dim s1, s2 as string(64)
	
	dim setting_result as en_stg_status_codes
	
	device_settings_sg=EN_STG_STATUS_OK
	
	if rw=DEVICE_GET then
		select case setting_name
		case "TD":
			rtc.getdata(w1,w2,b1)
			b2=val(stg_get("TZ",0))
			b3=val(stg_get("DS",0))
			td_gmt_to_local(w1,w2,b2,b3)
			td_to_str(setting_val,w1,w2,b1,0)
			td_str_date_time_reformat(setting_val,TD_STR_ADD_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
			setting_val=left(setting_val,10)
		case "TT":
			rtc.getdata(w1,w2,b1)
			b2=val(stg_get("TZ",0))
			b3=val(stg_get("DS",0))
			td_gmt_to_local(w1,w2,b2,b3)
			td_to_str(setting_val,w1,w2,b1,0)
			setting_val=mid(setting_val,9,6)
			td_str_time_reformat(setting_val,TD_STR_ADD_FORMATTING)
		case else:
			b1=instr(1,setting_name,"@",1)
			if b1>0 then
				index=val(right(setting_name,len(setting_name)-b1))
				setting_name=left(setting_name,b1-1)
			end if
			setting_result=stg_sg(setting_name,index,setting_val,EN_STG_GET)
			if setting_result=EN_STG_STATUS_OK then
				if chr(stg_stype_get(setting_name))="D" then
					b1=0
					do 
						b2=instr(b1+1,setting_val,chr(46),1)
						if b2>0 then
							s1=mid(setting_val,b1+1,b2-b1-1)
						else
							s1=right(setting_val,len(setting_val)-b1)
						end if
						while len(s1)<3
							s1="0"+s1
						wend
						s2=s2+s1+chr(46)
						b1=b2
					loop while b1<>0
					setting_val=left(s2,len(s2)-1)
				end if	
			end if
			device_settings_sg=setting_result		
		
		end select
	else
		select case setting_name
		case "TD":
			b2=val(stg_get("TZ",0))
			b3=val(stg_get("DS",0))
			
			rtc.getdata(w1,w2,b1)
			td_gmt_to_local(w1,w2,b2,b3)
			td_str_date_time_reformat(setting_val,TD_STR_REMOVE_FORMATTING,TD_DATE_FORMAT_YYYYMMDD)
			td_from_str(setting_val,w1,w3,b4,0)
			td_local_to_gmt(w1,w2,b2,b3)
			rtc.setdata(w1,w2,b1)
		case "TT":
			b2=val(stg_get("TZ",0))
			b3=val(stg_get("DS",0))
			
			rtc.getdata(w1,w2,b1)
			td_gmt_to_local(w1,w2,b2,b3)
			td_str_time_reformat(setting_val,TD_STR_REMOVE_FORMATTING)
			setting_val="20010101"+setting_val
			td_from_str(setting_val,w3,w2,b1,0)
			td_local_to_gmt(w1,w2,b2,b3)
			rtc.setdata(w1,w2,b1)
		case else:
			b1=instr(1,setting_name,"@",1)
			if b1>0 then
				index=val(right(setting_name,len(setting_name)-b1))
				setting_name=left(setting_name,b1-1)
			end if		
			device_settings_sg=stg_sg(setting_name,index,setting_val,EN_STG_SET)
		end select	
	end if
	
end function


#if SUPPORTS_DISPLAY
'------------------------------------------------------------------------------
sub lcd_display_button(F1_ADD as word,
	F2_ADD as word,
	F3_ADD as word,
	F4_ADD as word, 			'F#_ADD are the offset address of the icon in the BMP file.
	byref on_off as string(4),  'on_off string consist with 4 characters (0 or 1), which indicates if the icon is highlighted.  For example if on_off="0100", this means, only icon F2 are highlighted, rest are normal.
	repaint as no_yes,			'If repaint=yes, then all 4 icons are refreshed, else only the those icons that are previously or now highlighted, are being refreshed.
	revert as no_yes			'If revert=yes, then switch lcd forecolor and backcolor, meaning those icons which were normal, now are highlighted, and vice versa.
	)
'This function prints 4 stored icon images on the LCD, 
	dim F1_on,F2_on,F3_on,F4_on as no_yes
	dim x, y, w as word
	
	x=18
	y=SETTING_VAL_Y+SETTING_VAL_H
	w=83
	if mid(on_off,1,1)="0" then F1_on=NO else F1_on=YES 
	if mid(on_off,2,1)="0" then F2_on=NO else F2_on=YES 
	if mid(on_off,3,1)="0" then F3_on=NO else F3_on=YES 
	if mid(on_off,4,1)="0" then F4_on=NO else F4_on=YES 
	
	if repaint=YES then 
	romfile.open(ICON_FILE)	

		lcd.forecolor=LCD_FORECOLOR
		lcd.backcolor=LCD_BACKCOLOR
	LCD_LOCK	
		lcd_clear(1,y-1,lcd.width-1,33)
		lcd.bmp(romfile.offset,x-13,y,F1_ADD,0,40,31)
		lcd.bmp(romfile.offset,x+w,y,F2_ADD,0,40,31)
		lcd.bmp(romfile.offset,x+w*2,y,F3_ADD,0,40,31)
		lcd.bmp(romfile.offset,x+w*3+10,y,F4_ADD,0,40,31)
	LCD_UNLOCK

	end if
	romfile.open(ICON_FILE)
	if revert=NO then
		lcd.forecolor=LCD_BACKCOLOR
		lcd.backcolor=LCD_FORECOLOR
	else
		lcd.forecolor=LCD_FORECOLOR
		lcd.backcolor=LCD_BACKCOLOR
	end if

	LCD_LOCK
	if F1_on=yes then lcd.bmp(romfile.offset,x-13,y,F1_ADD,0,40,31)
	if F2_on=yes then lcd.bmp(romfile.offset,x+w,y,F2_ADD,0,40,31)
	if F3_on=yes then lcd.bmp(romfile.offset,x+w*2,y,F3_ADD,0,40,31)
	if F4_on=yes then lcd.bmp(romfile.offset,x+w*3+10,y,F4_ADD,0,40,31)
	LCD_UNLOCK
	lcd.forecolor=LCD_FORECOLOR
	lcd.backcolor=LCD_BACKCOLOR
end sub

'------------------------------------------------------------------------------
public sub device_ui_menu_command(s as string)

end sub

'------------------------------------------------------------------------------
public sub device_move_cursor(menu_item as menu_display_item,desc_file as string(30))
	dim setting_val as string
	dim color1, color2 as word
	dim i,j as word
	dim sname as string(8)
	dim item_data as string
	dim setting_type as string(1)
	dim b as byte
	
	color1=lcd.forecolor
	color2=lcd.backcolor
	romfile.open(desc_file)
	romfile.pointer=menu_item.display_item_data_addr
	item_data=romfile.getdata(menu_item.display_item_data_len)
	i=instr(1,item_data,chr(COMMA),2)
	j=instr(1,item_data,chr(COMMA),3)	
	sname=mid(item_data,i+1,j-i-1)
	if left(item_data,1)<>"S" or sname="" or sname="PW" or sname="WP" then
		lcd.forecolor=BG_BLUE
		lcd.fill(INPUT_BOX_X,INPUT_BOX_Y,INPUT_BOX_W,INPUT_BOX_H)
	else
'check if cursor moved to a list item, if so, display the item description in the menu discription file
		i=instr(1,item_data,chr(COMMA),1)
		j=instr(1,item_data,chr(COMMA),2)
		setting_type=mid(item_data,i+1,j-i-1)
		select case setting_type
		case "L":
			j=instr(1,item_data,chr(COMMA),3)
			item_data=mid(item_data,j+1,len(item_data)-j)
			i=instr(1,item_data,"-",1)
				
			if device_settings_sg(sname,0,setting_val,b,DEVICE_GET)=EN_STG_STATUS_OK and setting_val<>"" then
				if setting_val<>left(item_data,i-1) then
					setting_val=";"+setting_val+"-"
					i=instr(1,item_data,setting_val,1)+len(setting_val)-1
				end if
				j=instr(i,item_data,";",1)
				setting_val=mid(item_data,i+1,j-i-1)
			end if
		case "I":
			device_settings_sg(sname,0,setting_val,b,DEVICE_GET)
		case "T":
		end select
		if setting_val <> "" then
			romfile.open(LCD_STD_FONT)
			lcd.setfont(romfile.offset)
			lcd.forecolor=LCD_DISABLE_FORECOLOR
			lcd.backcolor=BG_BLUE
			lcd_print_msg(setting_val,SETTING_VAL_X+SCROLL_CURSOR_WIDTH,SETTING_VAL_Y,SETTING_VAL_W-SETTING_VAL_X-SCROLL_CURSOR_WIDTH,SETTING_VAL_H,PL_LCD_TEXT_ALIGNMENT_MIDDLE_LEFT,no)
		else
			lcd.forecolor=BG_BLUE
			lcd.fill(INPUT_BOX_X,INPUT_BOX_Y,INPUT_BOX_W,INPUT_BOX_H)
		end if
	end if
	lcd.forecolor=color1
	lcd.backcolor=color2	
end sub

'------------------------------------------------------------------------------
public sub device_menu_pre(
	x_coord as word,	'x coordination
	y_coord as word,	'y coordination
	width as word,		'width of the menu in pixel
	height as word,		'height of the menu in pixel
	byref menu_states as string(MENU_MAX_LVL),	'allows user to start up the menu inside of selected sub-folders instead of root.  example: if menu_state="23" then the menu will started at 2nd folder of menu lvl 1, 3rd folder of menu lvl 2. if menu_state="" then menu started at root.
	byref menu_descriptor_file as string(20),		'the descriptor file
	access_level as byte, 		'access level of the user, only the menu item that is small or equal to access_level will show.
	timeout as byte				'if no respond from the keypad within the time defined by "timeout", exit the menu and return to the previous screen. If timeout=0, no time out applies
	)

	lcd_display_button(BMP_CANCEL_XOFFSET,BMP_UP_XOFFSET,BMP_DOWN_XOFFSET,BMP_ENTER_XOFFSET,"0000",yes,no)
	lcd.forecolor=BG_BLUE
	lcd.fill(INPUT_BOX_X,INPUT_BOX_Y,INPUT_BOX_W,INPUT_BOX_H)
end sub

'------------------------------------------------------------------------------
public sub device_menu_post(
	x_coord as word,	'x coordination
	y_coord as word,	'y coordination
	width as word,		'width of the menu in pixel
	height as word,		'height of the menu in pixel
	byref menu_states as string(MENU_MAX_LVL),	'allows user to start up the menu inside of selected sub-folders instead of root.  example: if menu_state="23" then the menu will started at 2nd folder of menu lvl 1, 3rd folder of menu lvl 2. if menu_state="" then menu started at root.
	byref menu_descriptor_file as string(20),		'the descriptor file
	access_level as byte, 		'access level of the user, only the menu item that is small or equal to access_level will show.
	timeout as byte				'if no respond from the keypad within the time defined by "timeout", exit the menu and return to the previous screen. If timeout=0, no time out applies
	)
	lcd_clear(x_coord, y_coord-UM_VER_SPACING/2-SCROLL_BORDER-1, width-SCROLL_BAR_WIDTH-SCROLL_BORDER*2, height+UM_VER_SPACING+SCROLL_BORDER)
end sub

'------------------------------------------------------------------------------
public sub device_input_box_pre(
	byref mask_str as string(IB_MAX_LEN),	'uneditable part of the input string
	byref edit_str as string(IB_MAX_LEN),	'input string
	char_range as input_box_char_ranges,	'the input range. INPUT_BOX_CHAR_RANGE_09 only allows numeric input, INPUT_BOX_CHAR_RANGE_AZ allows alphabetic, INPUT_BOX_CHAR_RANGE_09AZ allows both numeric and alphabetic input.
	secret_mode as no_yes,			'if secret_mode=yes, all editable part of the input string will be display on the LCD as "*", this are mostly used for password.
	insert_mode as no_yes,			'if insert_mode=yes, the new character is insert before the cursor, if insert_mode=no, the character replaces the character at the cursor position.
	byref initial_pos as byte,			'initial cursor position
	timeout as byte,				'if no keypad activity for the amount of time defined by timeout, input box is automatically closed and return to previous screen.
	input_length as byte			'the maximum number of characters
)

	lcd_display_button(BMP_CANCEL_XOFFSET,BMP_NUM_XOFFSET,BMP_LEFT_XOFFSET,BMP_ENTER_XOFFSET,"0000",yes,no)
	lcd.forecolor=LCD_INPUTBOX_BACKCOLOR
	lcd.fill(INPUT_BOX_X,INPUT_BOX_Y,INPUT_BOX_W,INPUT_BOX_H)
	lcd.forecolor=LCD_INPUTBOX_FORECOLOR
	lcd.backcolor=LCD_INPUTBOX_BACKCOLOR
	input_box_mode=INPUT_BOX_NUMERIC
	ib_init=YES
end sub

'------------------------------------------------------------------------------
public sub device_input_box_post(
	byref mask_str as string(IB_MAX_LEN),	'uneditable part of the input string
	byref edit_str as string(IB_MAX_LEN),	'input string
	char_range as input_box_char_ranges,	'the input range. INPUT_BOX_CHAR_RANGE_09 only allows numeric input, INPUT_BOX_CHAR_RANGE_AZ allows alphabetic, INPUT_BOX_CHAR_RANGE_09AZ allows both numeric and alphabetic input.
	secret_mode as no_yes,			'if secret_mode=yes, all editable part of the input string will be display on the LCD as "*", this are mostly used for password.
	insert_mode as no_yes,			'if insert_mode=yes, the new character is insert before the cursor, if insert_mode=no, the character replaces the character at the cursor position.
	byref initial_pos as byte,			'initial cursor position
	timeout as byte,				'if no keypad activity for the amount of time defined by timeout, input box is automatically closed and return to previous screen.
	input_length as byte			'the maximum number of characters
)

	lcd.forecolor=LCD_FORECOLOR
	lcd.backcolor=LCD_BACKCOLOR

end sub

'------------------------------------------------------------------------------
public sub device_list_box_pre(
	x_coord as word,		'x coordination
	y_coord as word,		'y coordination
	list_width as word,		'list box width
	list_height as word,	'list box height
	byref listbox_data as string,		'values and display strings of all list box items
	byref listbox_state as string(10),	'the value of selected list box item 
	timeout as byte						'if no respond from the keypad within the time defined by "timeout", exit the list box and return to the previous screen. If timeout=0, no time out applies
	)
	
	lcd_display_button(BMP_CANCEL_XOFFSET,BMP_UP_XOFFSET,BMP_DOWN_XOFFSET,BMP_ENTER_XOFFSET,"0000",yes,no)
end sub

'------------------------------------------------------------------------------
public sub device_list_box_post(
	x_coord as word,		'x coordination
	y_coord as word,		'y coordination
	list_width as word,		'list box width
	list_height as word,	'list box height
	byref listbox_data as string,		'values and display strings of all list box items
	byref listbox_state as string(10),	'the value of selected list box item 
	byref disable_print as no_yes,
	timeout as byte						'if no respond from the keypad within the time defined by "timeout", exit the list box and return to the previous screen. If timeout=0, no time out applies
	)
	
end sub

'------------------------------------------------------------------------------
public sub device_msg_box_pre(
	byref msg as string(160), 			'message to be displayed in the Message Box
	x as word, 							'x coordination
	y as word, 							'y coordination
	w as word, 							'width of the msgbox
	h as word, 							'height of the msgbox
	align as pl_lcd_text_alignment, 	'alignment of the text in the msgbox
	byref keycode_str as string(20),	'this string contains the characters which ASCII is correspond to the keycode of keys on the keypad that msgbox responds to 
	bolder as no_yes, 					'if the msgbox is wrap with a visible bolder line
	timeout as byte						'if no respond from the keypad within the time defined by "timeout", exit the msgbox and return to the previous screen. If timeout=0, no time out applies
	)
	
	dim color as word

	if msg=EXIT_MENU then
		color=lcd.forecolor
		lcd.forecolor=BG_BLUE
		lcd.fill(INPUT_BOX_X,INPUT_BOX_Y,INPUT_BOX_W,INPUT_BOX_H)
		lcd.forecolor=color
	end if
end sub

'------------------------------------------------------------------------------
public sub device_msg_box_post(
	byref msg as string(60), 			'message to be displayed in the Message Box
	x as word, 							'x coordination
	y as word, 							'y coordination
	w as word, 							'width of the msgbox
	h as word, 							'height of the msgbox
	align as pl_lcd_text_alignment, 	'alignment of the text in the msgbox
	byref keycode_str as string(20),	'this string contains the characters which ASCII is correspond to the keycode of keys on the keypad that msgbox responds to 
	bolder as no_yes, 					'if the msgbox is wrap with a visible bolder line
	timeout as byte						'if no respond from the keypad within the time defined by "timeout", exit the msgbox and return to the previous screen. If timeout=0, no time out applies
	)
	lcd_clear(MSG_BOX_X,MSG_BOX_Y,MSG_BOX_W,MSG_BOX_H)
	lcd_clear(0,SETTING_VAL_Y+SETTING_VAL_H+2,lcd.width,lcd.height-SETTING_VAL_Y-SETTING_VAL_H-2)
end sub

'------------------------------------------------------------------------------
public sub device_ib_timer_event(byref current_state as input_box_key_actions,byref key_asc as byte,byref insert_mode as no_yes)
	if ib_chr_timer=0 then exit sub
	ib_chr_timer=ib_chr_timer-1
	if ib_chr_timer=0 then
		chr_init=YES
		key_asc=255
		current_state=INPUT_BOX_POS_FORWARD
	end if
end sub

'------------------------------------------------------------------------------
sub device_ib_interrupt()
	
end sub

'------------------------------------------------------------------------------
sub device_lb_interrupt()
end sub

'------------------------------------------------------------------------------
sub device_mb_interrupt()
end sub

'------------------------------------------------------------------------------
sub device_menu_interrupt()
end sub

'------------------------------------------------------------------------------
public sub lcd_clear(x as word, y as word, width as word, height as word)
	dim color as word
	color=lcd.forecolor
	lcd.forecolor=lcd.backcolor
	lcd.fill(x,y,width,height)
	lcd.forecolor=color
end sub

'------------------------------------------------------------------------------
public sub lcd_print_msg(byref msg as string,x as word, y as word, w as word, h as word, al as pl_lcd_text_alignment, bolder as no_yes)
'This is a popup msgbox, it prints a message on the LCD.
	lcd.textverticalspacing=MSB_VER_SPACING
	lcd.texthorizontalspacing=MSB_HOR_SPACING
	lcd.textalignment=al
	lcd.printaligned(msg,x,y,w,h)
	lcd.linewidth=2
	if bolder=YES then lcd.rectangle(x,y,x+w,y+h)
end sub

'------------------------------------------------------------------------------
public function device_mb_get_key(mk as en_mb_keys) as string
	select case mk
	case MBK_COMMAND_CANCEL: 	device_mb_get_key=chr(KEY_F4)
	case MBK_YES: 				device_mb_get_key=chr(KEY_F4)
	case MBK_OK: 				device_mb_get_key=chr(KEY_F4)
	case MBK_COMMAND_CONFIRM: 	device_mb_get_key=chr(KEY_F1)
	case MBK_NO: 				device_mb_get_key=chr(KEY_F1)
	case MBK_F1:				device_mb_get_key=chr(KEY_F1)
	case MBK_F2:				device_mb_get_key=chr(KEY_F2)
	case MBK_F4:				device_mb_get_key=chr(KEY_F4)
	end select
end function

'------------------------------------------------------------------------------
public sub device_menu_key_proc(key_event as pl_kp_event_codes, key_code as byte, byref current_state as menu_key_actions)
	select case key_event
	case PL_KP_EVENT_PRESSED:
		beep.play(BEEP_VERY_SHORT,PL_PAT_CANINT)
		select case key_code
		case KEY_F1: 'F1
			current_state=MENU_KEY_OUT
		case KEY_F2: 'F2
			current_state=MENU_KEY_UP
		case KEY_F3: 'F3
			current_state=MENU_KEY_DOWN
		case KEY_F4: 'F4
			current_state=MENU_KEY_IN
		case else 
			current_state=255
		end select
	case PL_KP_EVENT_RELEASED:
	case else
	end select
end sub

'------------------------------------------------------------------------------
public sub device_ib_key_proc(key_event as pl_kp_event_codes, key_code as byte, byref current_state as input_box_key_actions, byref key_asc as byte, byref insert_mode as no_yes)
	select case key_event
	case PL_KP_EVENT_PRESSED:

		beep.play(BEEP_VERY_SHORT,PL_PAT_CANINT)

		select case key_code
		case KEY_F1: 'F1
			current_state=INPUT_BOX_CANCEL
		case KEY_F2: 'F2
			current_state=INPUT_BOX_CHAR_FORWARD
		case KEY_F3: 'F3
			current_state=INPUT_BOX_POS_FORWARD
		case KEY_F4: 'F4
			current_state=INPUT_BOX_CONFIRM
		case else 
			current_state=INPUT_BOX_NONE
		end select
	case PL_KP_EVENT_RELEASED:
		current_state=INPUT_BOX_NONE
	end select
	
end sub

'------------------------------------------------------------------------------
public sub device_lb_key_proc(key_event as pl_kp_event_codes, key_code as byte, byref current_state as list_box_key_action)

	select case key_event
	case PL_KP_EVENT_PRESSED:
		beep.play(BEEP_VERY_SHORT,PL_PAT_CANINT)

		select case key_code
		case KEY_F1: 'F1,C
			
			current_state=LIST_BOX_CANCEL
		case KEY_F2: 'F2
			
			current_state=LIST_BOX_CURSOR_UP
		case KEY_F3: 'F3
			
			current_state=LIST_BOX_CURSOR_DOWN
		case KEY_F4: 'F4,E
			
			current_state=LIST_BOX_CONFIRM
		case else
			current_state=255
		end select
	case PL_KP_EVENT_RELEASED:
		current_state=255
	case else
		current_state=255
	end select

end sub

'------------------------------------------------------------------------------
public sub device_mb_key_proc(key_event as pl_kp_event_codes, key_code as byte)

end sub

'------------------------------------------------------------------------------
public sub set_stg_modified()

end sub

'------------------------------------------------------------------------------
sub reset_keypad()

end sub

sub lcd_print_dhcp(interface as pl_sock_interfaces, x as word, y as word)
	dim s as string(20)
	
	if interface = PL_SOCK_INTERFACE_PPP then
		if interface = PL_SOCK_INTERFACE_PPP then
			if current_interface = PL_SOCK_INTERFACE_PPP then
				s = "PPP OK`ACTIVE"
			else
				s = "PPP OK`I/F IDLE"
			end if
		end if
	else
		s = "DHCP"
		
		if (interface = PL_SOCK_INTERFACE_NET and param_dh = NO) or 
		   (interface = PL_SOCK_INTERFACE_WLN and param_wd = NO) then
			s = s + " OFF"
		else
			if ip_configured(interface) = NO then
				s = s + "..."
			else
				if dhcp_failed(interface - 1) = NO then
					s = s + " OK"
				else
					s = s + " fail"
				end if
			end if
		end if

		if interface = PL_SOCK_INTERFACE_WLN then
			if current_interface = PL_SOCK_INTERFACE_WLN then
				s = s + "`" + "ACTIVE"
			else
				s = s + "`" + "I/F IDLE"
			end if
		end if

	end if

	lcd_print_bottom_text(s, x, y + 12, 100, 20)
end sub

sub lcd_print_ip(byref ip as string, x as word, y as word)

	lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_TOP_RIGHT
	lcd.printaligned(ddstr(left(ddval(ip),3))+".", x + 20, y + 2, 103-20-12, lcd.fontheight)
	
	romfile.open("11x19(HP).bin")
	lcd.setfont(romfile.offset)
	lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_TOP_RIGHT
	lcd.printaligned(ddstr(right(ddval(ip),1)), x + 53, y + 17, 103-53-10, lcd.fontheight)
	romfile.open("Tibbo-5x7(V).bin") 'default font
	lcd.setfont(romfile.offset)

end sub

sub lcd_print_top_text(byref text as string, x as word, y as word, width as word, height as word)

	lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_TOP_LEFT
	lcd.printaligned(text, x, y, width, height)
	
end sub

sub lcd_print_bottom_text(byref text as string, x as word, y as word, width as word, height as word)
	
	lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_BOTTOM_LEFT
	lcd.printaligned(text, x, y, width, height)
	
end sub

sub lcd_print_icon(byref name as string, x as word, y as word)

	romfile.open(name)
	lcd.bmp(romfile.offset, x, y, 0, 0, 100, 100)

end sub

sub lcd_display_tibbo(byref text as string)

	'lcd_clear(110, 100, lcd.width, lcd.height)
	
	lcd_print_icon("logo.bmp", 150, 90)
	romfile.open("Tibbo-5x7(V).bin") 'we need a real bitmap logo
	lcd.setfont(romfile.offset)
	lcd.textalignment=PL_LCD_TEXT_ALIGNMENT_BOTTOM_CENTER
	lcd.printaligned(text, 100, 110, lcd.width - 100, 40)
	
end sub

function lcd_get_symbol_analog_pin(slot as byte, pin as byte) as string(1)

	dim io_num as byte
	
	io_num = (slot * 4) + pin
	
	lcd_get_symbol_analog_pin = ""
	
	select case param_st(slot)
	case SLOT_IA_4:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "I"
		else
			lcd_get_symbol_analog_pin = "X"
		end if

	case SLOT_IA_RTD:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "I"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	case SLOT_IA_52:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "I"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	case SLOT_IA_53:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "I"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	case SLOT_OA_4:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "O"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	case SLOT_OA_3:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "I"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	case SLOT_DP:
		if param_io(io_num).io_enabled = YES then
			lcd_get_symbol_analog_pin = "R"
		else
			lcd_get_symbol_analog_pin = "X"
		end if
		
	end select
end function

function lcd_get_symbol_digital_pin(slot as byte, pin as byte) as string(1)
	
	dim io_num as byte
	
	io_num = (slot * 4) + pin
	
	lcd_get_symbol_digital_pin = ""

	select case param_st(slot)
	case SLOT_IOD_4:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				if param_io(io_num).io_output = YES then
					lcd_get_symbol_digital_pin = "O"
				else
					lcd_get_symbol_digital_pin = "I"
				end if
			end if
		end if
		
	case SLOT_IOD_3:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				if param_io(io_num).io_output = YES then
					lcd_get_symbol_digital_pin = "O"
				else
					lcd_get_symbol_digital_pin = "I"
				end if
			end if
		end if
		
	case SLOT_IOD_2:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				if param_io(io_num).io_output = YES then
					lcd_get_symbol_digital_pin = "O"
				else
					lcd_get_symbol_digital_pin = "I"
				end if
			end if
		end if
		
	case SLOT_ID_4:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				lcd_get_symbol_digital_pin = "I"
			end if
		end if
		
	case SLOT_ID_3:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				lcd_get_symbol_digital_pin = "I"
			end if
		end if
		
	case SLOT_ID_2:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			if io_cn(io_num).mode <> io_counter_disabled then
				lcd_get_symbol_digital_pin = "C"
			else 	
				lcd_get_symbol_digital_pin = "I"
			end if
		end if
		
	case SLOT_OD_4:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			lcd_get_symbol_digital_pin = "O"
		end if
		
	case SLOT_OD_2:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			lcd_get_symbol_digital_pin = "I"
		end if
		
	case SLOT_OD_1:
		if param_io(io_num).io_enabled = NO then 
			lcd_get_symbol_digital_pin = "X"
		else 
			lcd_get_symbol_digital_pin = "I"
		end if
		
	end select
	
end function

sub lcd_channel_fault(channel as byte)
	
	dim corn_x, corn_y, step_y, offset_icon as word
	dim inv_pin as boolean

	if (channel < NUM_OF_SLOTS) then
		if (channel > 3) then 	' UP SIDE TPP2
			corn_x = (7 - channel) * 80 + 3
			corn_y = 5
			lcd_clear(corn_x, 0, 80, 20)
		else					' DOWN SIDE TPP2
			corn_x = channel * 80 + 3
			corn_y = 225
			lcd_clear(corn_x, 220, 80, 20)
		end if
		
		lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER
		lcd.printaligned("FAULT", corn_x, corn_y, 80, 8)

	end if
end sub

sub lcd_display_channel(channel as byte)
	dim ch as byte
	dim s as string(40)
	dim out as string(40)
	dim corn_x, corn_y, step_y, offset_icon as word
	dim inv_pin as boolean
	dim cp as boolean

	out = ""
	
	if (channel < NUM_OF_SLOTS) then
		if (channel > 3) then 	' UP SIDE TPP2
			corn_x = (7 - channel) * 80 + 3
			corn_y = 30
			step_y = -10
			offset_icon = -28
			inv_pin = true
			lcd_clear(corn_x, 0, 80, 50)
		else					' DOWN SIDE TPP2
			corn_x = channel * 80 + 3
			corn_y = 200
			step_y = 10
			offset_icon = 20
			inv_pin = false
			lcd_clear(corn_x, corn_y, 80, 240 - corn_y)
		end if

		lcd.forecolor = LCD_FORECOLOR
		lcd.backcolor = LCD_BACKCOLOR
		s = "CH#" + str(channel + 1)

		lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER
		lcd.printaligned(s, corn_x, corn_y, 80, 8)

		if channel = 1 or channel = 3 then
			if param_st(channel - 1) = SLOT_SERIAL_02 or 
			   param_st(channel - 1)  = SLOT_IA_52 or
			   param_st(channel - 1)  = SLOT_IA_53 then
			
				lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER		
				lcd.printaligned("OCCUPIED", corn_x, corn_y + step_y, 80, 8)	
				exit sub
			end if
		end if
		
		select case param_st(channel)
		case SLOT_EMPTY:
			s = "EMPTY"
			
		case SLOT_SERIAL_01:
			s = "#01 RS232"
			lcd_serial_print(channel, corn_x, corn_y)
			
		case SLOT_SERIAL_02:
			if channel < 4 then
				s = "#02"
				if channel < 4 then
					select case param_sp(channel)
					case 0: s = s + " Disable"
					case 1: s = s + " RS232"
					case 2: s = s + " RS422"
					case 3: s = s + " RS485"
					case else: s = s + " UNKN"
					end select
				end if
				lcd_serial_print(channel, corn_x, corn_y)
			else
				s = "UNKNOWN"
			end if
			
		case SLOT_SERIAL_05:
			' Check BP available
			s = "#05 RS485"
			if bp_ports(channel).enable then
				lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER		
				lcd.printaligned("BProbes", corn_x, corn_y + step_y*2, 80, 8)	
			else
				lcd_serial_print(channel, corn_x, corn_y)
			end if
			
		case SLOT_IOD_4:
			s = "IOD4"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_IOD_3:
			s = "IOD3"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_IOD_2:
			s = "IOD2"
			' Check CP
			cp = false
			if channel < NUM_I2C_SLOTS then
				if io_cprobes(channel) <> IO_CPROBE_DISABLE then cp = true
			end if
			if cp = false then
				lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
				lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
				lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
				lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			else
				lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER		
				select case io_cprobes(channel)
				case IO_CPROBE_TEMP:
					lcd.printaligned("CP#01 #29", corn_x, corn_y + step_y*2, 80, 8)	
					
				case IO_CPROBE_TEMPHUM:
					lcd.printaligned("CP#02 #30", corn_x, corn_y + step_y*2, 80, 8)	
					
				case IO_CPROBE_LIGHT:
					lcd.printaligned("CP#03 #28", corn_x, corn_y + step_y*2, 80, 8)	
					
				case IO_CPROBE_PRESSURE:
					lcd.printaligned("#35", corn_x, corn_y + step_y*2, 80, 8)	
					
				end select
			end if
			
		case SLOT_ID_4:
			s = "ID4"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_ID_3:
			s = "ID3"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_ID_2:
			s = "ID2"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
		
		case SLOT_OD_4:
			s = "OD4"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_OD_2:
			s = "OD2"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_OD_1:
			s = "OD1"
			lcd_print_io_pin(lcd_get_symbol_digital_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 1, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_IA_4:
			s = "IA4"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_IA_RTD:
			s = "RTD"
			
		case SLOT_IA_52:
			s = "#52"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_IA_53:
			s = "#53"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 1, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_OA_4:
			s = "OA4"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 3), 3, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			
		case SLOT_OA_3:
			s = "OA3"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 1), 1, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 2), 2, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		case SLOT_DP:
			s = "DP"
			lcd_print_io_pin(lcd_get_symbol_analog_pin(channel, 0), 0, inv_pin, corn_x, corn_y + offset_icon, LCD_FORECOLOR)
			lcd_print_io_pin("X", 1, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 2, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			lcd_print_io_pin("X", 3, inv_pin, corn_x, corn_y + offset_icon, LCD_DISABLE_FORECOLOR)
			
		end select

		lcd.forecolor = LCD_FORECOLOR
		lcd.backcolor = LCD_BACKCOLOR
		lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER
		lcd.printaligned(s, corn_x, corn_y + step_y, 80, 8)
		
	end if

end sub

sub lcd_serial_print(sernum as byte, corn_x as byte, corn_y as byte)
	
	dim s as string(16)
	dim i as word
	
	ser.num = sernum
	
	if ser.baudrate <= ser.div9600 then
		i = ser.div9600 / ser.baudrate
		select case i
		case 1
			s = "9600"
		case 2
			s = "19200"
		case 4
			s = "38400"
		case 6
			s = "57600"
		case 12
			s = "115200"
		case 24
			s = "230400"
		case else
			s = "460800"
		end select
	else
		i = ser.baudrate / ser.div9600
		select case i
		case 2
			s = "4800"
		case 4
			s = "2400"
		case 8
			s = "1200"
		case 64
			s = "150"
		case 32
			s = "300"
		case 16
			s = "600"
		case else
			s = "28800"
		end select
	end if

	if ser.bits = PL_SER_BB_7 then
		s = s + "-7"
	else	
		s = s + "-8"
	end if

	select case ser.parity
	case PL_SER_PR_NONE: s = s + "N1"
	
	case PL_SER_PR_EVEN: s = s + "E1"
	
	case PL_SER_PR_ODD: s = s + "O1"
	
	case PL_SER_PR_MARK: s = s + "M1"
	
	case PL_SER_PR_SPACE: s = s + "S1"
		
	end select

	lcd.textalignment = PL_LCD_TEXT_ALIGNMENT_MIDDLE_CENTER
	lcd.printaligned(s, corn_x, corn_y + 20, 80, 8)

	if ser.flowcontrol = DISABLED then
		s = "NONE F/C`"
	else if ser.flowcontrol = PL_SER_FC_RTSCTS then
		s = "RTS/CTS`"
	else
		s = "XON/XOFF`"
	end if

	lcd.printaligned(s, corn_x, corn_y + 30, 80, 8)

end sub

sub lcd_display_page(page as enum_lcd_pages, mode as enum_lcd_print_modes, element as enum_lcd_print_elements)

	lcd.backcolor = LCD_BACKCOLOR
	lcd.forecolor = LCD_FORECOLOR

	if lcd_error_mode = false then
		select case page
		case LCD_PAGE_NET:
			lcd_clear(0, 45, 106, 45)
			if net.linkstate = PL_NET_LINKSTAT_NOLINK then
				lcd_print_icon("ethernet_unplugged.bmp", 3, 50)
				lcd_print_top_text("UNPLUGGED", 30, 53, 106 - 30, 8)
			else
				lcd_print_icon("ethernet_plugged.bmp", 3, 50)
				lcd_print_dhcp(PL_SOCK_INTERFACE_NET, 3, 50)
				lcd_print_ip(net.ip, 3, 50)
			end if

		case LCD_PAGE_WLN:
			lcd_clear(0, 100, 106, 45)
			if wln_already_started = YES then	
				dim s as string(30)

				if wln_error <> NO then

					select case wln_result
					case WLN_STATUS_BOOT_FAILURE:		s = "Wi-Fi interface not present"
					case WLN_STATUS_INVALID_WEP_KEY:	s = "Invalid WEP password"
					case else:							s = "Firmware error"
					end select
				
					lcd_print_icon("wifi_error.bmp", 3, 100)
					lcd_print_top_text("Wi-Fi ERROR", 20, 102, 106 - 20, 8)
					lcd_print_top_text(s, 0, 106, 106, 20)
				else
					if interface_ready(PL_SOCK_INTERFACE_WLN)=NO then

						select case wln_result
						case WLN_STATUS_OK:							s = " "
						case WLN_STATUS_SCANNING_FAILURE:			s = "AP not found"
						case WLN_STATUS_ASSOCIATION_FAILURE:		s = "Association failure"
						case WLN_STATUS_DISASSOCIATION:				s = "Disassociated"
						case WLN_STATUS_UNEXPECTED_ERROR:			s = "Unexpected error"
						case else:									s = "Firmware error"
						end select
						
						lcd_print_icon("wifi_connecting.bmp", 3, 100)
						lcd_print_top_text(param_wa, 20, 102, 106 - 20, 8)
						lcd_print_top_text("CONNECTING...`" + s, 0, 117, 106, 8)
					else
						dim x as byte
						x = (wln.rssi / 40) + 1
						if x > 5 then x = 5
						select case x
						case 1:	lcd_print_icon("wifi_signal_1.bmp", 3, 100)
						case 2: lcd_print_icon("wifi_signal_2.bmp", 3, 100)
						case 3:	lcd_print_icon("wifi_signal_3.bmp", 3, 100)
						case 4:	lcd_print_icon("wifi_signal_4.bmp", 3, 100)
						case 5:	lcd_print_icon("wifi_signal_5.bmp", 3, 100)
						end select

						lcd_print_dhcp(PL_SOCK_INTERFACE_WLN, 0, 100)
						lcd_print_ip(wln.ip, 0, 100)
					end if
				end if
			else
				lcd_print_icon("wifi_off.bmp", 3, 100)
				lcd_print_top_text("Wi-Fi OFF", 20, 102, 106 - 20, 8)
			end if

		case LCD_PAGE_ERROR:
			if lcd_error_mode = false then
				lcd_display_tibbo("ERROR MODE!`Press & hold to reinitialize the device.")
				lcd_error_mode = true
			end if
			
		case LCD_PAGE_LOGO:
			lcd_display_tibbo("Booting...")	

		case LCD_PAGE_LOGO_WORK:
			lcd_display_tibbo("RemoteIO")	
		
		case LCD_PAGE_INIT_START:
			lcd_display_tibbo("INIT IN PROGRESS`Do not power off the device!")
		
		case LCD_PAGE_INIT_DONE
			lcd_display_tibbo("INIT COMPLETE`Reboot the device now")
			
		end select
	end if
	
end sub

sub lcd_print_io_pin(s as string(1), pin as byte, inverse as boolean, base_x as word, base_y as word, color as word)
	
	dim rpin as byte
	dim x1, y1 as word
	dim x2, y2 as word
	dim w, h as word
	
	if inverse = true then 
		rpin = 3 - pin
	else
		rpin = pin
	end if
	
	x1 = base_x + (18 * rpin) + 4
	x2 = base_x + (18 * rpin) + 15 + 4
	y1 = base_y
	y2 = base_y + 15
	w = x2 - x1 - 2
	h = y2 - y1 - 2
	lcd.forecolor = color
	lcd.backcolor = LCD_BACKCOLOR
	lcd.filledrectangle(x1, y1, x2, y2)
	lcd.printaligned(s, x1 + 1, y1 + 1, w, h)
	lcd.forecolor = LCD_FORECOLOR

end sub

#endif
